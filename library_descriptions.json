{
    "xml-python": "\nA library for making Python objects from XML.\n",
    "xlrd": "\n   \nxlrd is a library for reading data and formatting information from Excel\nfiles in the historical .xls format.\n\nWarning\nThis library will no longer read anything other than .xls files. For\nalternatives that read newer file formats, please see http://www.python-excel.org/.\n\nThe following are also not supported but will safely and reliably be ignored:\n\nCharts, Macros, Pictures, any other embedded object, including embedded worksheets.\nVBA modules\nFormulas, but results of formula calculations are extracted.\nComments\nHyperlinks\nAutofilters, advanced filters, pivot tables, conditional formatting, data validation\n\nPassword-protected files are not supported and cannot be read by this library.\nQuick start:\nimport xlrd\nbook = xlrd.open_workbook(\"myfile.xls\")\nprint(\"The number of worksheets is {0}\".format(book.nsheets))\nprint(\"Worksheet name(s): {0}\".format(book.sheet_names()))\nsh = book.sheet_by_index(0)\nprint(\"{0} {1} {2}\".format(sh.name, sh.nrows, sh.ncols))\nprint(\"Cell D30 is {0}\".format(sh.cell_value(rowx=29, colx=3)))\nfor rx in range(sh.nrows):\n    print(sh.row(rx))\nFrom the command line, this will show the first, second and last rows of each sheet in each file:\npython PYDIR/scripts/runxlrd.py 3rows *blah*.xls\n",
    "thrift": "\nThrift Python Software Library\nLicense\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements. See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership. The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied. See the License for the\nspecific language governing permissions and limitations\nunder the License.\nUsing Thrift with Python\nThrift is provided as a set of Python packages. The top level package is\nthrift, and there are subpackages for the protocol, transport, and server\ncode. Each package contains modules using standard Thrift naming conventions\n(i.e. TProtocol, TTransport) and implementations in corresponding modules\n(i.e. TSocket).  There is also a subpackage reflection, which contains\nthe generated code for the reflection structures.\nThe Python libraries can be installed manually using the provided setup.py\nfile, or automatically using the install hook provided via autoconf/automake.\nTo use the latter, become superuser and do make install.\n",
    "Theano-PyMC": "\nTheano is a Python library that allows you to define, optimize, and efficiently evaluate mathematical expressions involving multi-dimensional arrays. It is built on top of NumPy. Theano features:\n\n\ntight integration with NumPy: a similar interface to NumPy\u2019s. numpy.ndarrays are also used internally in Theano-compiled functions.\ntransparent use of a GPU: perform data-intensive computations up to 140x faster than on a CPU (support for float32 only).\nefficient symbolic differentiation: Theano can compute derivatives for functions of one or many inputs.\nspeed and stability optimizations: avoid nasty bugs when computing expressions such as log(1 + exp(x)) for large values of x.\ndynamic C code generation: evaluate expressions faster.\nextensive unit-testing and self-verification: includes tools for detecting and diagnosing bugs and/or potential problems.\n\n\nTheano has been powering large-scale computationally intensive scientific\nresearch since 2007, but it is also approachable enough to be used in the\nclassroom (IFT6266 at the University of Montreal).\n",
    "spacy-legacy": "\n\nspacy-legacy: Legacy functions and architectures for backwards compatibility\nThis package includes outdated registered functions for spaCy v3.x, for example model architectures, pipeline components and utilities. It's installed automatically as a dependency of spaCy, and allows us to provide backwards compatibility, while keeping the core library tidy and up to date. All of this happens under the hood, so you typically shouldn't have to care about this package.\n\n\nHow it works\nWhenever a new backwards-incompatible version of a registered function is available, e.g. spacy.Tok2Vec.v1 \u2192 spacy.Tok2Vec.v2, the legacy version is moved to spacy-legacy, and exposed via entry points. This means that it will still be available if your config files use it, even though the core library only includes the latest version.\nLegacy functions are exposed with the prefix spacy-legacy, e.g. spacy-legacy.Tok2Vec.v1. When spaCy resolves your config and a function is not available in the core library, e.g. spacy.Tok2Vec.v1, it will check if there's a legacy function available and fall back to that. You can also explicitly refer to legacy functions in your config, to indicate that a newer version is available.\n",
    "reportlab": "\nThe ReportLab Toolkit. An Open Source Python library for generating PDFs and graphics.\n",
    "pydub": "\nManipulate audio with an simple and easy high level interface.\nSee the README file for details, usage info, and a list of gotchas.\n",
    "pexpect": "\nPexpect is a pure Python module for spawning child applications; controlling\nthem; and responding to expected patterns in their output. Pexpect works like\nDon Libes\u2019 Expect. Pexpect allows your script to spawn a child application and\ncontrol it as if a human were typing commands.\nPexpect can be used for automating interactive applications such as ssh, ftp,\npasswd, telnet, etc. It can be used to a automate setup scripts for duplicating\nsoftware package installations on different servers. It can be used for\nautomated software testing. Pexpect is in the spirit of Don Libes\u2019 Expect, but\nPexpect is pure Python.\nThe main features of Pexpect require the pty module in the Python standard\nlibrary, which is only available on Unix-like systems. Some features\u2014waiting\nfor patterns from file descriptors or subprocesses\u2014are also available on\nWindows.\n",
    "openpyxl": "\n\n\nIntroduction\nopenpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm files.\nIt was born from lack of existing library to read/write natively from Python\nthe Office Open XML format.\nAll kudos to the PHPExcel team as openpyxl was initially based on PHPExcel.\n\n\nSecurity\nBy default openpyxl does not guard against quadratic blowup or billion laughs\nxml attacks. To guard against these attacks install defusedxml.\n\n\nMailing List\nThe user list can be found on http://groups.google.com/group/openpyxl-users\nSample code:\nfrom openpyxl import Workbook\nwb = Workbook()\n\n# grab the active worksheet\nws = wb.active\n\n# Data can be assigned directly to cells\nws['A1'] = 42\n\n# Rows can also be appended\nws.append([1, 2, 3])\n\n# Python types will automatically be converted\nimport datetime\nws['A2'] = datetime.datetime.now()\n\n# Save the file\nwb.save(\"sample.xlsx\")\n\n\nDocumentation\nThe documentation is at: https://openpyxl.readthedocs.io\n\ninstallation methods\ncode examples\ninstructions for contributing\n\nRelease notes: https://openpyxl.readthedocs.io/en/stable/changes.html\n\n",
    "numba": "\n\n\n\n\n\n\nA Just-In-Time Compiler for Numerical Functions in Python\nNumba is an open source, NumPy-aware optimizing compiler for Python sponsored\nby Anaconda, Inc.  It uses the LLVM compiler project to generate machine code\nfrom Python syntax.\nNumba can compile a large subset of numerically-focused Python, including many\nNumPy functions.  Additionally, Numba has support for automatic\nparallelization of loops, generation of GPU-accelerated code, and creation of\nufuncs and C callbacks.\nFor more information about Numba, see the Numba homepage:\nhttps://numba.pydata.org and the online documentation:\nhttps://numba.readthedocs.io/en/stable/index.html\n\nInstallation\nPlease follow the instructions:\nhttps://numba.readthedocs.io/en/stable/user/installing.html\n\n\nDemo\nPlease have a look and the demo notebooks via the mybinder service:\nhttps://mybinder.org/v2/gh/numba/numba-examples/master?filepath=notebooks\n\n\nContact\nNumba has a discourse forum for discussions:\n\nhttps://numba.discourse.group\n\n\n\n",
    "nbformat": "\nThis package contains the base implementation of the Jupyter Notebook format,and Python APIs for working with notebooks.\n",
    "ipython-genutils": "\nPretend this doesn\u2019t exist. Nobody should use it.\n",
    "geographiclib": "\nPython implementation of the geodesic routines in GeographicLib\nThis is a library to solve geodesic problems on an ellipsoid model of\nthe earth.\nLicensed under the MIT/X11 License; see\nLICENSE.txt.\nThe algorithms are documented in\n\nC. F. F. Karney,\nAlgorithms for geodesics,\nJ. Geodesy 87(1), 43\u201355 (2013);\nAddenda.\n\nThe documentation for this package is in\nhttps://geographiclib.sourceforge.io/Python/doc\n",
    "future": "\nfuture: Easy, safe support for Python 2/3 compatibility=======================================================``future`` is the missing compatibility layer between Python 2 and Python3. It allows you to use a single, clean Python 3.x-compatible codebase tosupport both Python 2 and Python 3 with minimal overhead.It is designed to be used as follows::    from __future__ import (absolute_import, division,                            print_function, unicode_literals)    from builtins import (             bytes, dict, int, list, object, range, str,             ascii, chr, hex, input, next, oct, open,             pow, round, super,             filter, map, zip)followed by predominantly standard, idiomatic Python 3 code that then runssimilarly on Python 2.6/2.7 and Python 3.3+.The imports have no effect on Python 3. On Python 2, they shadow thecorresponding builtins, which normally have different semantics on Python 3versus 2, to provide their Python 3 semantics.Standard library reorganization~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``future`` supports the standard library reorganization (PEP 3108) through thefollowing Py3 interfaces:    >>> # Top-level packages with Py3 names provided on Py2:    >>> import html.parser    >>> import queue    >>> import tkinter.dialog    >>> import xmlrpc.client    >>> # etc.    >>> # Aliases provided for extensions to existing Py2 module names:    >>> from future.standard_library import install_aliases    >>> install_aliases()    >>> from collections import Counter, OrderedDict   # backported to Py2.6    >>> from collections import UserDict, UserList, UserString    >>> import urllib.request    >>> from itertools import filterfalse, zip_longest    >>> from subprocess import getoutput, getstatusoutputAutomatic conversion--------------------An included script called `futurize<http://python-future.org/automatic_conversion.html>`_ aids in convertingcode (from either Python 2 or Python 3) to code compatible with bothplatforms. It is similar to ``python-modernize`` but goes further inproviding Python 3 compatibility through the use of the backported typesand builtin functions in ``future``.Documentation-------------See: http://python-future.orgCredits-------:Author:  Ed Schofield, Jordan M. Adler, et al:Sponsor: Python Charmers Pty Ltd, Australia, and Python Charmers Pte          Ltd, Singapore. http://pythoncharmers.com:Others:  See docs/credits.rst or http://python-future.org/credits.htmlLicensing---------Copyright 2013-2019 Python Charmers Pty Ltd, Australia.The software is distributed under an MIT licence. See LICENSE.txt.\n",
    "et-xmlfile": "\net_xmfile=========et_xmlfile is a low memory library for creating large XML files.It is based upon the `xmlfile module from lxml <http://lxml.de/api.html#incremental-xml-generation>`_ with the aim of allowing code to be developed that will work with both libraries. It was developed initially for the openpyxl project but is now a standalone module.The code was written by Elias Rabel as part of the `Python D\u00fcsseldorf <http://pyddf.de>`_ openpyxl sprint in September 2014.Note on performance-------------------The code was not developed with performance in mind but turned out to be faster than the existing SAX-based implementation but is significantly slower than lxml's xmlfile. There is one area where an optimisation for lxml will negatively affect the performance of et_xmfile and that is when using the `.element()` method on an xmlfile context manager. It is, therefore, recommended not to use this, though the method is provided for code compatibility.\n",
    "cffi": "\nForeign Function Interface for Python calling C code.\nPlease see the Documentation.\n\nContact\nMailing list\n\n",
    "beautifulsoup4": "\nBeautiful Soup is a library that makes it easy to scrape information\nfrom web pages. It sits atop an HTML or XML parser, providing Pythonic\nidioms for iterating, searching, and modifying the parse tree.\nQuick start\n>>> from bs4 import BeautifulSoup\n>>> soup = BeautifulSoup(\"<p>Some<b>bad<i>HTML\")\n>>> print(soup.prettify())\n<html>\n <body>\n  <p>\n   Some\n   <b>\n    bad\n    <i>\n     HTML\n    </i>\n   </b>\n  </p>\n </body>\n</html>\n>>> soup.find(text=\"bad\")\n'bad'\n>>> soup.i\n<i>HTML</i>\n#\n>>> soup = BeautifulSoup(\"<tag1>Some<tag2/>bad<tag3>XML\", \"xml\")\n#\n>>> print(soup.prettify())\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<tag1>\n Some\n <tag2/>\n bad\n <tag3>\n  XML\n </tag3>\n</tag1>\n\nTo go beyond the basics, comprehensive documentation is available.\nLinks\n\nHomepage\nDocumentation\nDiscussion group\nDevelopment\nBug tracker\nComplete changelog\n\nNote on Python 2 sunsetting\nBeautiful Soup's support for Python 2 was discontinued on December 31,\n2020: one year after the sunset date for Python 2 itself. From this\npoint onward, new Beautiful Soup development will exclusively target\nPython 3. The final release of Beautiful Soup 4 to support Python 2\nwas 4.9.3.\nSupporting the project\nIf you use Beautiful Soup as part of your professional work, please consider a\nTidelift subscription.\nThis will support many of the free software projects your organization\ndepends on, not just Beautiful Soup.\nIf you use Beautiful Soup for personal projects, the best way to say\nthank you is to read\nTool Safety, a zine I\nwrote about what Beautiful Soup has taught me about software\ndevelopment.\nBuilding the documentation\nThe bs4/doc/ directory contains full documentation in Sphinx\nformat. Run make html in that directory to create HTML\ndocumentation.\nRunning the unit tests\nBeautiful Soup supports unit test discovery using Pytest:\n$ pytest\n\n",
    "python-apt": "\nhttp://apt.alioth.debian.org/python-apt-doc/\n",
    "PyGObject": "\n\n\n\n\nPyGObject is a Python package which provides bindings for GObject based libraries such as GTK, GStreamer,\nWebKitGTK, GLib, GIO and many more.\nIt supports Linux, Windows and macOS and works with Python 3.7+ and\nPyPy3. PyGObject, including this documentation, is licensed under the\nLGPLv2.1+.\n\nFor more information visit https://pygobject.readthedocs.io\n",
    "PyAudio": "\n\nPyAudio\nPyAudio provides Python bindings for PortAudio v19, the cross-platform audio I/O library. With PyAudio, you can easily use Python to play and record audio on a variety of platforms, such as GNU/Linux, Microsoft Windows, and Apple macOS.\nPyAudio is distributed under the MIT License.\n\nHomepage\nAPI Documentation\nPyPi\n\nInstallation\nSee the INSTALLATION file in the source distribution for details. In summary, install PyAudio using pip on most platforms.\nWindows\npython -m pip install pyaudio\n\nThis installs the precompiled PyAudio library with PortAudio v19 19.7.0 included. The library is compiled with support for Windows MME API, DirectSound, WASAPI, and WDM-KS. It does not include support for ASIO. If you require support for APIs not included, you will need to compile PortAudio and PyAudio.\nmacOS\nUse Homebrew to install the prerequisite portaudio library, then install PyAudio using pip:\nbrew install portaudio\npip install pyaudio\n\nGNU/Linux\nUse the package manager to install PyAudio. For example, on Debian-based systems:\nsudo apt install python3-pyaudio\n\nAlternatively, if the latest version of PyAudio is not available, install it using pip. Be sure to first install development libraries for portaudio19 and python3.\nBuilding from source\nSee the INSTALLATION file.\nDocumentation & Usage Examples\n\n\nRead the API Documentation, or generate it from the source using sphinx.\n\n\nUsage examples are in the examples directory of the source distribution, or see the project homepage.\n\n\nLicense\nPyAudio is distributed under the MIT License. See LICENSE.txt.\n",
    "distro-info": "",
    "dbus-python": "\ndbus-python is the original Python binding for dbus, the reference\nimplementation of the D-Bus protocol.\nOnline documentation can be found at\n<http://dbus.freedesktop.org/doc/dbus-python/>.\n\nProblems and alternatives\ndbus-python might not be the best D-Bus binding for you to use. dbus-python\ndoes not follow the principle of \u201cIn the face of ambiguity, refuse the\ntemptation to guess\u201d, and can\u2019t be changed to not do so without seriously\nbreaking compatibility.\nIn addition, it uses libdbus (which has known problems with multi-threaded\nuse) and attempts to be main-loop-agnostic (which means you have to select\na suitable main loop for your application).\nAlternative ways to get your Python code onto D-Bus include:\n\nGDBus, part of the GIO module of GLib, via GObject-Introspection and\nPyGI (uses the GLib main loop and object model)\nQtDBus, part of Qt, via PyQt (uses the Qt main loop and object model)\n\n\n"
}